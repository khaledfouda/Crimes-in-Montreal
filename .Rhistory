data = merge(interv, pdq, by='PDQ', all.x = TRUE)
names(data)
#--------------------------
# 2 - keep releveant variables, rename variables and expand the date,
# and translate some features from french to English
#---------------------------
# Keep only relevant columns
data %>% select( CATEGORIE, DATE, QUART, NOM_TEMP, MUN_TEMP,
LONGITUDE.x, LATITUDE.x) -> data
# Translate Categories and day time
catg.fr = table(data$CATEGORIE) %>% names
catg.en = c("Resulting Death", "Break and Enter", "Mischief", "Auto Burglary",
"Auto theft", "Armed Robbery")
catg.rep = function(c) catg.en[which(catg.fr==c)]
quart.fr = table(data$QUART) %>% names
quart.en = c('Day', 'Night', 'Evening')
quart.rep = function(c) quart.en[which(quart.fr==c)]
# Apply changes and extract the Year and month
data %>% mutate(CATEGORIE = mapply(catg.rep,CATEGORIE),
DATE = as.Date(DATE, "%Y-%m-%d"),
QUART = mapply(quart.rep, QUART),
STREET = NOM_TEMP, NOM_TEMP = NULL,
MUNICIP = MUN_TEMP, MUN_TEMP = NULL) -> data
data$MONTH = month(data$DATE)
data$YEAR = year(data$DATE)
#-------------------------------------------------------------------
# 3 - Discard obsevations of the current month (May 2021)
#since the data won't be complete.
#-------------------------------------
data %>% filter( !(YEAR ==2021 & MONTH==5 )) -> data
write.csv(data, './data/Police_Interventions_cleaned.csv')
require(reticulate)
require(tidygeocoder)
#--------------------------------------------------------
# read the list in case it was previousely saved and do the cleaning mentioned above.
addrss = read.csv('./data/neighbs.csv')
# print  a sample
head(addrss$x,2)
ext.nei = function(addr){
ext = paste(unlist((strsplit(addr,',')[[1]] %>% tail(7))[1:3]),collapse = ',')
return(ext)
}
# Now apply to the list
addrss$ext=mapply(ext.nei,addrss$x )
# Add the municiplity for comparison reasons.
addrss$munc = data$MUNICIP
# For most of the locations, the second item is the neighbourhood so
# we set the neighbourhoods to it and later correct the wrong ones.
addrss$nei = mapply( function(d) strsplit(d,",")[[1]][2], addrss$ext)
table(addrss$nei)
# We notice two things:
# 1. Locations in "Dorval" are set to "Agglomeration de montreal"
# 2. All Motreal's (city not island) neighbourhoods are the first item of the list
# not the second.
addrss %>% filter(nei==" Montréal") %>% select(X) -> mtl.ids
addrss[unlist(mtl.ids),]$nei = mapply( function(d) strsplit(d,",")[[1]][1],
addrss[unlist(mtl.ids),]$ext)
# Similarly for Dorval
addrss %>% filter(nei==" Agglomération de Montréal") %>% select(X) -> drv.ids
addrss[unlist(drv.ids),]$nei = mapply( function(d) strsplit(d,",")[[1]][1],
addrss[unlist(drv.ids),]$ext)
table(addrss$nei)
# Add municiplity in place of NA values, to be corrected in exel.
addrss %>% mutate( nei = ifelse(nei=='NA',munc,nei) ) -> addrss
#---------
# All seems okay, a couple of further notes:
# 1. Some locations didn't have long/lat values and their address is set to NA
# I will fix them by guessing the neighborhoods using the street name and city values.
# 2. Some names in the list needs to be shortened so it's easier to visualize.
# I will fix that in a Excel file.
require(openxlsx)
write.xlsx(table(addrss$nei), './data/list_neighbourhoods.xlsx')
new.addrss = read.xlsx('./data/list_neighbourhoods_corrected.xlsx',
rowNames = FALSE,colNames = FALSE)
# Replace addresses in the dataframe addess
for(i in 1:nrow(new.addrss)){
addrss %>% mutate( nei=replace(nei, nei==new.addrss[i,1], new.addrss[i,2])) -> addrss
}
table(addrss$nei) %>% as.data.frame() %>% arrange(desc(Freq))
#-----------------------------------------
# Some of those under the category "louis Riel" belong to either Anjou or Mercier
addrss %>% filter(nei=="Louis-Riel") %>% select(X) -> lr.ids
addrss[unlist(lr.ids),]$nei = mapply(
function(d) ifelse(d=="ANJ","Anjou","Mercier-Hochelaga-Maisonneuve"),
addrss[unlist(lr.ids),]$munc)
round((table(addrss$nei)/sum(table(addrss$nei)))*100,2) %>%
as.data.frame() %>% arrange(desc(Freq))
#----------------------
# 12.92% of the data has unknown location.
# Now we merge the data.
data$borough = addrss$nei
data$X = NULL
data$STREET = NULL
data$MUNICIP = NULL
write.csv(data, './data/Police_Interventions_cleaned.csv')
View(data %>% arrange(date))
View(data %>% arrange(DATE))
data %>% arrange(DATE) %>% group_by(DATE) %>% summarise(length(CATEGORIE)) %>% View
n()
data %>% arrange(DATE) %>% group_by(DATE) %>% summarise(count = n()) %>% View
data %>%
arrange(DATE) %>%
group_by(DATE) %>%
summarise(count = n()) %>%
write.csv('./data/ts_all_categories.csv')
data %>%
arrange(DATE) %>%
group_by(DATE) %>%
summarise(count = n()) %>%
write.csv('./data/ts_all_categories.csv',row.names = FALSE)
data$CATEGORIE
for(cat in table(data$CATEGORIE))
table(data$CATEGORIE)
table(data$CATEGORIE)
for(cat in unlist(table(data$CATEGORIE)))
unlist(table(data$CATEGORIE))
unlist(table(data$CATEGORIE))
rownames(table(data$CATEGORIE))
cat = rownames(table(data$CATEGORIE))[4]
cat
strsplit(cat,' ')
strsplit(cat,' ')[[1]]
paste(strsplit(cat,' ')[[1]],sep = '_')
paste0(strsplit(cat,' ')[[1]],sep = '_')
paste0(strsplit(cat,' ')[[1]],collapse = '_,sep = '_')
paste0(strsplit(cat,' ')[[1]],collapse = '_',sep = '_')
paste0(strsplit(cat,' ')[[1]],collapse = '_')
strsplit(cat,' ')[[1]]
cat = rownames(table(data$CATEGORIE))[5]
cat
paste0(strsplit(cat,' ')[[1]],collapse = '_')
paste0('./data/ts_',paste0(strsplit(cat,' ')[[1]],collapse = '_'),'.csv')
for(cat in rownames(table(data$CATEGORIE))){
file.name = paste0('./data/ts_',paste0(strsplit(cat,' ')[[1]],collapse = '_'),'.csv')
data %>%
filter(CATEGORIE==cat) %>%
arrange(DATE) %>%
group_by(DATE) %>%
summarise(count = n()) %>%
write.csv(file.name, row.names=FALSE)
}
data = read.csv('./data/ts_all_categories.csv')
View(data)
require(dplyr)
data %>%
group_by(month(DATE)) %>%
summarise(count = n())
data %>%
mutate(MONTH = month(DATE)) %>%
group_by(MONTH) %>%
summarise(count = n())
month
require(lubridate)
data %>%
mutate(MONTH = month(DATE)) %>%
group_by(MONTH) %>%
summarise(count = n())
data %>%
mutate(YYM =format_ISO8601(Date, precision = 'ym')) %>%
group_by(YYM) %>%
summarise(count = n())
data %>%
mutate(YYM =format(Date, precision = 'ym')) %>%
group_by(YYM) %>%
summarise(count = n())
data %>%
mutate(YYM =format(Date, precision = 'ym')
)
data %>%
mutate(YYM =format(Date, 'ym')) %>%
group_by(YYM) %>%
summarise(count = n())
data %>%
mutate(YYM =format(Date, '%y-%m')) %>%
group_by(YYM) %>%
summarise(count = n())
format(data$DATE, "%y-%m")
data %>%
mutate(paste0(year(Date),'-',month(Date))) %>%
group_by(YYM) %>%
summarise(count = n())
paste0(year(data$DATE),'-',month(data$DATE))
format_ISO8601(data$DATE, "%y-%m")
format_ISO8601(data$DATE, precision = "ym")
data %>%
mutate(paste0(year(DATE),'-',month(DATE))) %>%
group_by(YYM) %>%
summarise(count = n())
data %>%
mutate(YYM=paste0(year(DATE),'-',month(DATE))) %>%
group_by(YYM) %>%
summarise(count = n())
paste0(year(data$DATE),'-',sprintf("%02d",month(data$DATE)))
data %>%
mutate(YYM=paste0(year(DATE),'-',sprintf("%02d",month(DATE)))) %>%
group_by(YYM) %>%
summarise(count = n())
data %>%
mutate(YYM=paste0(year(DATE),'-',sprintf("%02d",month(DATE)))) %>%
group_by(YYM) %>%
summarise(count = n()) -> data
dts = ts(data$count, start = c(2005,1), end=c(2021,4),frequency = 12)
plot(dts)
# Take a subset
dts.subs = window(dts, start=c(2005,1), end=c(2020,12))
plot(dts.subs)
#------------------
# Seasonal Decomposition (stl) <trend, seasonality, irregular components>
fit = stl(dts, s.window = "period")
plot(fit)
# Additional plots
monthplot(dts)
seasonplot(myts)
library(forecast)
seasonplot(myts)
seasonplot(dts)
par(mfrow=c(1,3))
plot(fit)
# Additional plots
monthplot(dts)
library(forecast)
seasonplot(dts)
x11()
plot(fit)
# Additional plots
monthplot(dts)
library(ggplot2)
library(grid)
library(gridExtra)
layout <- matrix(c(1, 2, 1, 3), nrow = 2, byrow = TRUE)
multiplot(plotlist = plots, layout = layout)
library(scater)
library(ggplot2)
library(ggplot2)
library(grid)
library(gridExtra)
multiplot(plotlist = plots, layout = layout)
multiplot(plotlist = c(plot(fit),monthplot(dts),seasonplot(dts)), layout = layout)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
require(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
multiplot(plotlist = c(plot(fit),monthplot(dts),seasonplot(dts)), layout = layout)
multiplot(plotlist = list(plot(fit),monthplot(dts),seasonplot(dts)), layout = layout)
multiplot(plotlist = list(plot(fit),monthplot(dts),seasonplot(dts)), layout = layout)
x11()
plot(fit)
# Additional plots
x11()
par(mfrow=c(2,1))
monthplot(dts)
library(forecast)
seasonplot(dts)
library(xts)
#-----------------------
# Using xts
data.d = read.csv('./data/ts_all_categories.csv')
dts.x = xts(data.d$count, order.by = data.d$DATE)
seq(as.Date("2005-01-01"), as.Date("2021-04-30"), "day")
date.x = seq(as.Date("2005-01-01"), as.Date("2021-04-30"), "day")
dts.x = xts(data.d$count, order.by = date.x)
nrow(date.x)
nrow(data)
nrow(data.d)
length(date.x)
data.d$DATE
date.x
dts.x = xts(data.d$count, order.by = date.x)
dts.x = xts(data.d$count, order.by = data.d$DATE)
dts.x = xts(data.d$count, order.by = as.Date(data.d$DATE))
plot(dts.x)
data = read.csv('./data/ts_all_categories.csv')
# group by Year-Month
data %>%
mutate(YYM=paste0(year(DATE),'-',sprintf("%02d",month(DATE)))) %>%
group_by(YYM) %>%
summarise(count = n()) -> data
# Define time series
dts = ts(data$count, start = c(2015,1), end=c(2021,4),frequency = 12)
plot(dts)
# Take a subset
dts.subs = window(dts, start=c(2015,1), end=c(2020,12))
plot(dts.subs)
#------------------
# Seasonal Decomposition (stl) <trend, seasonality, irregular components>
fit = stl(dts, s.window = "period")
x11()
plot(fit,)
# Additional plots
x11()
par(mfrow=c(2,1))
monthplot(dts)
library(forecast)
seasonplot(dts)
data.d = read.csv('./data/ts_all_categories.csv')
dts.x = xts(data.d$count, order.by = as.Date(data.d$DATE))
plot(dts.x)
data.d = read.csv('./data/ts_all_categories.csv')
dts.x = xts(data.d$count, order.by = as.Date(data.d$DATE))
plot(dts.x)
data.d = read.csv('./data/ts_all_categories.csv')
dts.x = xts(data.d$count, order.by = as.Date(data.d$DATE))
plot(dts.x)
dts.x.month <- apply.monthly(dts.x, mean)
plot(dts.x.month, ylim = range(dts.x))
plot(fit)
# double Exp: models and trend
fit = HoltWinters(dts, gamma=FALSE)
plot(fit)
# triple exp: models, trend, seasonal
fit = HoltWinters(dts)
plot(fit)
# predict next three future values
forecast(fit, 3)
plot(forecast(fit, 3))
#------------------------------
#Automated Forecasting:
## forecast automatically selects exponenttial and arima model.
#he ets() function supports both additive and multiplicative models.
#The auto.arima() function can handle both seasonal and nonseasonal ARIMA models.
#Models are chosen to maximize one of several fit criteria
fit <- ets(myts)
#------------------------------
#Automated Forecasting:
## forecast automatically selects exponenttial and arima model.
#he ets() function supports both additive and multiplicative models.
#The auto.arima() function can handle both seasonal and nonseasonal ARIMA models.
#Models are chosen to maximize one of several fit criteria
fit <- ets(dts)
plot(fit)
fit <- auto.arima(myts)
plot(fit)
# Automated forecasting using an ARIMA model
fit <- auto.arima(dts)
plot(fit)
fit <- ets(dts)
plot(fit)
anova(fit)
aov(fit)
fit = HoltWinters(dts)
plot(fit)
anova(fit)
plot.ts(fit, type='multiple')
plot.ts(fit)
# triple exp: models, trend, seasonal
fit = HoltWinters(dts)
plot.ts(fit)
plot(fit)
plot(fit)
#---------------------------------
# Exponential Model
#>>
# simple - models level
fit = HoltWinters(dts, beta=FALSE, gamma=FALSE)
plot(fit)
# double Exp: models and trend
fit = HoltWinters(dts, gamma=FALSE)
plot(fit)
#------------------------------
#Automated Forecasting:
## forecast automatically selects exponenttial and arima model.
#he ets() function supports both additive and multiplicative models.
#The auto.arima() function can handle both seasonal and nonseasonal ARIMA models.
#Models are chosen to maximize one of several fit criteria
#-------------------------
# Automated forecasting using an exponential model
fit <- ets(dts)
plot(fit)
# Take a subset
dts.subs = window(dts, start=c(2015,1), end=c(2019,12))
plot(dts.subs)
# triple exp: models, trend, seasonal
fit = HoltWinters(dts.subs)
plot(fit)
# predict next three future values
forecast(fit, 16)
plot(forecast(fit, 3))
# predict next three future values
forecast(fit, 16)
# predict next three future values
pred = forecast(fit, 16)
pred
View(pred)
# predict next three future values
pred = as.data.frame(forecast(fit, 16))
View(pred)
dts
data
data %>%
mutate(YYM=paste0(year(DATE),'-',sprintf("%02d",month(DATE))))
data = read.csv('./data/ts_all_categories.csv')
# group by Year-Month
data %>%
mutate(YYM=paste0(year(DATE),'-',sprintf("%02d",month(DATE)))) %>% View
data %>%
mutate(YYM=paste0(year(DATE),'-',sprintf("%02d",month(DATE)))) %>% View
group_by(YYM) %>%
summarise(count = sum(count)) -> data
# group by Year-Month
data %>%
mutate(YYM=paste0(year(DATE),'-',sprintf("%02d",month(DATE)))) %>%
group_by(YYM) %>%
summarise(count = sum(count)) -> data
View(data)
equire(dplyr)
require(lubridate)
library(xts)
data = read.csv('./data/ts_all_categories.csv')
# group by Year-Month
data %>%
mutate(YYM=paste0(year(DATE),'-',sprintf("%02d",month(DATE)))) %>%
group_by(YYM) %>%
summarise(count = sum(count)) -> data
# Define time series
dts = ts(data$count, start = c(2015,1), end=c(2021,4),frequency = 12)
plot(dts)
# Take a subset
dts.subs = window(dts, start=c(2015,1), end=c(2019,12))
plot(dts.subs)
plot(dts.subs)
fit = stl(dts, s.window = "period")
x11()
plot(fit,)
# Additional plots
x11()
par(mfrow=c(2,1))
monthplot(dts)
library(forecast)
seasonplot(dts)
data.d = read.csv('./data/ts_all_categories.csv')
dts.x = xts(data.d$count, order.by = as.Date(data.d$DATE))
plot(dts.x)
dts.x.month <- apply.monthly(dts.x, mean)
plot(dts.x.month, ylim = range(dts.x))
fit = HoltWinters(dts, beta=FALSE, gamma=FALSE)
plot(fit)
fit = HoltWinters(dts, gamma=FALSE)
plot(fit)
fit = HoltWinters(dts.subs)
plot(fit)
pred = as.data.frame(forecast(fit, 16))
dts
dts[1]
dts[1,]
dim(dts)
data
tail(dts,16)
unlist(tail(dts,16))
c(tail(dts,16))
pred$Actual = c(tail(dts,16))
View(pred)
rownames(pred)
plot(rownmes(pred), pred$`Point Forecast`)
plot(rownames(pred), pred$`Point Forecast`)
rownames(pred)
plot(seq(1:16), pred$`Point Forecast`)
plot(seq(1:16), pred$`Point Forecast`,type = 'l')
plot(seq(1:16), pred$`Point Forecast`,type = 'l',col="blue")
points(plot(seq(1:16), pred$Actual,type = 'l',col="red"))
plot(seq(1:16), pred$`Point Forecast`,type = 'l',col="blue")
points(plot(seq(1:16), pred$Actual,type = 'l',col="red"))
points(plot(seq(1:16), pred$Actual,type = 'p',col="red"))
plot(seq(1:16), pred$`Point Forecast`,type = 'l',col="blue")
points(seq(1:16), pred$Actual,type = 'p',col="red")
points(seq(1:16), pred$Actual,type = 'l',col="red")
plot(seq(1:16), pred$`Point Forecast`,type = 'l',col="blue")
points(seq(1:16), pred$Actual,type = 'l',col="red")
min(pred$Actual)
max(pred$Actual)
plot(seq(1:16), pred$`Point Forecast`,type = 'l',col="blue",ylim = c(1344,2686))
points(seq(1:16), pred$Actual,type = 'l',col="red")
# Take a subset
dts.subs = window(dts, start=c(2015,1), end=c(2018,12))
plot(dts.subs)
# triple exp: models, trend, seasonal
fit = HoltWinters(dts.subs)
plot(fit)
pred = as.data.frame(forecast(fit, 28))
pred$Actual = c(tail(dts,28))
plot(forecast(fit, 3))
plot(seq(1:28), pred$`Point Forecast`,type = 'l',col="blue",ylim = c(1344,2686))
points(seq(1:28), pred$Actual,type = 'l',col="red")
abline(v=12)
abline(v=24)
fit <- ets(dts)
plot(fit)
fit <- auto.arima(dts)
plot(fit)
